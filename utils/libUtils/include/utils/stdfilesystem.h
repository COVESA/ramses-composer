/*
 * SPDX-License-Identifier: MPL-2.0
 *
 * This file is part of Ramses Composer
 * (see https://github.com/bmwcarit/ramses-composer).
 *
 * This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
 * If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
#pragma once

// Make it possible to use std::filesystem in Ubuntu 18 (with old compiler).

#if __has_include(<filesystem>)
#   include <filesystem>

// Needed to have unified syntax for path::lexically_normal which we cannot add to filesystem::experimental
namespace raco_filesystem_compatibility {
	inline std::filesystem::path lexically_normal(std::filesystem::path const& p) {
		return p.lexically_normal();
	}
}

#else
#	include <experimental/filesystem>

	namespace std {
		// We need the alias from std::experimental::filesystem to std::filesystem
		namespace filesystem = experimental::filesystem;

		// Functions missing from std::experimental::filesystem
		namespace experimental {
			namespace filesystem {

				// Copied from boost::filesytem (https://github.com/boostorg/filesystem, commit cc57d28,
				// with slight modifications (turning member functions into out of class functions etc)
				//
				// ------ Start code copied from Boost (slightly modified) ------
				/*
				Boost Software License - Version 1.0 - August 17th, 2003

					Permission is hereby granted, free of charge, to any person or organization
					obtaining a copy of the software and accompanying documentation covered by
					this license(the "Software") to use, reproduce, display, distribute,
					execute, and transmit the Software, and to prepare derivative works of the
					Software, and to permit third - parties to whom the Software is furnished to
					do so, all subject to the following :

				The copyright notices in the Softwareand this entire statement, including
					the above license grant, this restrictionand the following disclaimer,
					must be included in all copies of the Software, in whole or in part, and
					all derivative works of the Software, unless such copies or derivative
					works are solely in the form of machine - executable object code generated by
					a source language processor.

					THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
					IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
					FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT
					SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
					FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
					ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
					DEALINGS IN THE SOFTWARE.
				*/

				namespace detail {
				
					inline const path& dot_path()
					{
						static const path dot_pth(".");
						return dot_pth;
					}

					inline const path& dot_dot_path()
					{
						static const path dot_dot("..");
						return dot_dot;
					}

					inline std::pair<path::iterator, path::iterator> mismatch(path::iterator it1,
						path::iterator it1end, path::iterator it2, path::iterator it2end)
					{
						for (; it1 != it1end && it2 != it2end && *it1 == *it2;)
						{
							++it1;
							++it2;
						}
						return std::make_pair(it1, it2);
					}

					constexpr char dot = '.';
					constexpr char separator = '/';

					inline path lexically_normal(path const& p)
					{
						if (p.empty())
							return p;

						path temp;
						path::iterator start(p.begin());
						path::iterator last(p.end());
						path::iterator stop(last--);
						for (path::iterator itr(start); itr != stop; ++itr)
						{
							// ignore "." except at start and last
							if (itr->native().size() == 1
								&& (itr->native())[0] == dot
								&& itr != start
								&& itr != last) continue;

							// ignore a name and following ".."
							if (!temp.empty()
								&& itr->native().size() == 2
								&& (itr->native())[0] == dot
								&& (itr->native())[1] == dot) // dot dot
							{
								path::string_type lf(temp.filename().native());
								path::string_type::size_type lf_size = lf.size();
								if (lf_size > 0
									&& (lf_size != 1
										|| (lf[0] != dot
											&& lf[0] != separator))
									&& (lf_size != 2
										|| (lf[0] != dot
											&& lf[1] != dot
											)
										)
									)
								{
									temp.remove_filename();
									//// if not root directory, must also remove "/" if any
									//if (temp.native().size() > 0
									//  && temp.native()[temp.native().size()-1]
									//    == separator)
									//{
									//  string_type::size_type rds(
									//    root_directory_start(temp.native(), temp.native().size()));
									//  if (rds == string_type::npos
									//    || rds != temp.native().size()-1)
									//  {
									//    temp.m_pathname.erase(temp.native().size()-1);
									//  }
									//}

									path::iterator next(itr);
									if (temp.empty() && ++next != stop
										&& next == last && *last == detail::dot_path())
									{
										temp /= detail::dot_path();
									}
									continue;
								}
							}

							temp /= *itr;
						}

						if (temp.empty())
							temp /= detail::dot_path();
						return temp;
					}
				
					inline path weakly_canonical(const path& p, std::error_code* ec)
					{
						path head(p);
						path tail;
						std::error_code tmp_ec;
						path::iterator itr = p.end();

						for (; !head.empty(); --itr)
						{
							file_status head_status = status(head, tmp_ec);
							if (head_status.type() == file_type::none)
								return path();
							if (head_status.type() != file_type::not_found)
								break;
							head.remove_filename();
						}

						bool tail_has_dots = false;
						for (; itr != p.end(); ++itr)
						{
							tail /= *itr;
							// for a later optimization, track if any dot or dot-dot elements are present
							if (itr->native().size() <= 2
								&& itr->native()[0] == dot
								&& (itr->native().size() == 1 || itr->native()[1] == dot))
								tail_has_dots = true;
						}

						if (head.empty())
							return lexically_normal(p);
						head = canonical(head, tmp_ec);
						if (tmp_ec.value() != 0)
							return path();
						return tail.empty()
							? head
							: (tail_has_dots  // optimization: only normalize if tail had dot or dot-dot element
								? lexically_normal(head / tail)
								: head / tail);
					}
				
					inline path lexically_relative(const path& p, const path& base)
					{
						path::iterator b = p.begin(), e = p.end(), base_b = base.begin(), base_e = base.end();
						std::pair<path::iterator, path::iterator> mm = detail::mismatch(b, e, base_b, base_e);
						if (mm.first == b && mm.second == base_b)
							return path();
						if (mm.first == e && mm.second == base_e)
							return detail::dot_path();

						std::ptrdiff_t n = 0;
						for (; mm.second != base_e; ++mm.second)
						{
							path const& p = *mm.second;
							if (p == detail::dot_dot_path())
								--n;
							else if (!p.empty() && p != detail::dot_path())
								++n;
						}
						if (n < 0)
							return path();
						if (n == 0 && (mm.first == e || mm.first->empty()))
							return detail::dot_path();

						path tmp;
						for (; n > 0; --n)
							tmp /= detail::dot_dot_path();
						for (; mm.first != e; ++mm.first)
							tmp /= *mm.first;
						return tmp;
					}

					inline path lexically_proximate(const path& p, const path& base)
					{
						path tmp(lexically_relative(p, base));
						return tmp.empty() ? p : tmp;
					}

				}

				inline path proximate(const std::filesystem::path& p,
					const std::filesystem::path& base,
					std::error_code& ec) {
					// This is according to https://en.cppreference.com/w/cpp/filesystem/relative what the function does
					path pcan = detail::weakly_canonical(p, &ec);
					if (ec) return path();
					path basecan = detail::weakly_canonical(base, &ec);
					if (ec) return path();
					return detail::lexically_proximate(pcan, basecan);
				}

				// ------ End code copied from Boost (slightly modified) ------
			
			}
		
		}

	}

	// Needed to have unified syntax for path::lexically_normal which we cannot add to filesystem::experimental
	namespace raco_filesystem_compatibility {
		inline std::filesystem::path lexically_normal(std::filesystem::path const& p) {
			return std::experimental::filesystem::detail::lexically_normal(p);
		}
	}

#endif

